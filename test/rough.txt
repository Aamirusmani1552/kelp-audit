alice = 1000 cbETH
bob = 1000 cbETH
LRTDepositPool = 0 cbETH
rsETHTotalSupply = 0
totalETHInPool = 0

////////////////////
// first deposit ///
////////////////////

depositAmount = 500 cbETH
alice = 500 cbETH
bob = 1000 cbETH
LRTDepositPool = 500 cbETH
cbETHPrice = 1e18
totalETHInPool = 500 cbETH

rsETHPrice = if -> (supply = 0) 1 ETH -> True -> 1 ETH
             else -> totalETHInPool / rsETHTotalSupply

rsEthAmountToMint = depositAmount * cbETHPrice / rsETHPrice
                  = 500 * 1e18 / 1e18 = 500 rsETH
rsETHTotalSupply = 500 rsETH


////////////////////
// second deposit //
////////////////////

depositAmount = 500 cbETH
alice = 500 cbETH
bob = 500 cbETH
LRTDepositPool = 1000 cbETH
cbETHPrice = 1e18
totalETHInPool = 1000 cbETH (updated before calculating rsETHPrice)

rsETHPrice = if -> (supply = 500) 1 ETH
             else -> totalETHInPool / rsETHTotalSupply -> True -> 1000 / 500 = 2 ETH
rsEthAmountToMint = depositAmount * cbETHPrice / rsETHPrice
                  = 500 * 1e18 / 2e18 = 250 rsETH

rsETHTotalSupply = 500 + 250 = 750 rsETH


////////////////////
// third deposit ///
////////////////////
depositAmount = 500 cbETH
alice = 500 cbETH
bob = 0 cbETH
LRTDepositPool = 1500 cbETH
cbETHPrice = 1e18
totalETHInPool = 1500 cbETH (updated before calculating rsETHPrice)

rsETHPrice = if -> (supply = 750) 1 ETH
             else -> totalETHInPool / rsETHTotalSupply -> True -> 1500 / 750 = 2 ETH
rsEthAmountToMint = depositAmount * cbETHPrice / rsETHPrice
                  = 500 * 1e18 / 2e18 = 250 rsETH

rsETHTotalSupply = 750 + 250 = 1000 rsETH


////////////////////
// fourth deposit //
////////////////////
depositAmount = 500 cbETH
alice = 0 cbETH
bob = 0 cbETH
LRTDepositPool = 2000 cbETH
cbETHPrice = 1e18
totalETHInPool = 2000 cbETH (updated before calculating rsETHPrice)

rsETHPrice = if -> (supply = 1000) 1 ETH
             else -> totalETHInPool / rsETHTotalSupply -> True -> 2000 / 1000 = 2 ETH

rsEthAmountToMint = depositAmount * cbETHPrice / rsETHPrice
                  = 500 * 1e18 / 2e18 = 250 rsETH

rsETHTotalSupply = 1000 + 250 = 1250 rsETH


This is a potential issue as the user will get less rsETH than expected.


// @audit What about rebasing tokens?
// @audit what about erc777 tokens? would they work 


The calculation for amount of `RSETH` to be minted to the user for the deposit made depends upon the balances of different tokens deposited in the `LRTDepositPool`, `NodeDelegator` and `EigenLayer` strategies. But for the calculation of these deposit it uses `IERC20(asset).balanceOf(address(this))`. This simply means the amount of tokens that these contracts has not the actual amount deposited by the user. Now anyone can transfer the `asset` directly to the contracts and completely mess up the calculation which will result in less tokens to be minted to the users.


## Impact

The `LRTDepositPool::depositAsset(...))` function uses `LRTDepositPool::_mintRsETH(...)` function to calculate the amount of `RSETH` to be minted to the user. Here is a high level flow of the calls for the function:

```
LRTDepositPool::deposit()
           |_ LRTDepositPool::_mintRsETH() 
                      |_ LRTDepositPool::getRsETHAmountToMint() 
                                |_ LRTOracle::getAssetPrice()
                                |_ LRTOracle::getRSETHPrice()
                                            |_ LRTOracle::getSupportedAssetList()
                                            |_ LRTOracle::getAssetPrice()
                                            |_ LRTDepositPool::getTotalAssetDeposits()
@>                                                          |_ LRTDepositPool::getAssetDistributionData()
                                                                   |_ NodeDelegator::getAssetBalance()
```

When the call reaches to `LRTDepositPool::getAssetDistributionData()`, this function does the following calculation to check the total deposits made by the user:

```Javascript
    function getAssetDistributionData(address asset)
        public
        view
        override
        onlySupportedAsset(asset)
        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)
    {
        // Question: is here the right place to have this? Could it be in LRTConfig?
@>        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));

        uint256 ndcsCount = nodeDelegatorQueue.length;
        for (uint256 i; i < ndcsCount;) {
@>            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);
            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);
            unchecked {
                ++i;
            }
        }
    }
```

It just uses `IERC20(asset).balanceOf(address(this))` to get the balances stored in the contracts. But this balance doesn't mean that the balance returned is the actual deposit made. It is just the amount of token the contract hold. Now anybody can come and mess this calculation up by transferring `LRTDepositPool` and `NodeDelegator` some tokens directly without going through the `LRTDepositPool::deposit(...)`. Because of this transfer there will be no corresponding `RSETH` minted and the amount of tokens stored in the contract will be increased. So `assetLyingInDepositPool` and `assetLyingInNDCs` will return incorrect deposit data because of the amount transferred. 
Now when this amount is returned back to the caller function that is `LRTDepositPool::getTotalAssetDeposits(...)` it will be combined together and returned back to `LRTOracle::getRSETHPrice()` function:

```Javascript
    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {
        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =
            getAssetDistributionData(asset);
@>        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);
    }
```

When this amount is received by `LRTOracle::getRSETHPrice()`, it will multiply the amount will it's corresponding ETH conversion price. And will store it in `totalETHInPool`. Since the wrong info was returned from the previous function, the amount stored in `totalETHInPool` will be wrong(will be more if we say more precisely) as well.

```Javascript
    function getRSETHPrice() external view returns (uint256 rsETHPrice) {
        address rsETHTokenAddress = lrtConfig.rsETH();
        uint256 rsEthSupply = IRSETH(rsETHTokenAddress).totalSupply();

        if (rsEthSupply == 0) {
            return 1 ether;
        }

        uint256 totalETHInPool;
        address lrtDepositPoolAddr = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);

        address[] memory supportedAssets = lrtConfig.getSupportedAssetList();
        uint256 supportedAssetCount = supportedAssets.length;

        for (uint16 asset_idx; asset_idx < supportedAssetCount;) {
            address asset = supportedAssets[asset_idx];
            uint256 assetER = getAssetPrice(asset);

>@            uint256 totalAssetAmt = ILRTDepositPool(lrtDepositPoolAddr).getTotalAssetDeposits(asset);
            totalETHInPool += totalAssetAmt * assetER;

            unchecked {
                ++asset_idx;
            }
        }
        // @audit can we manipulate the price and get more rsEth? or can we manipulate the price and make the rsEth more
        // expensive?
        return totalETHInPool / rsEthSupply;
    }
```

And in the end this `totalETHInPool` is used to return the ratio of total Eth deposited to total `RSETH` supply. Or we can say for a single `RSETH` minted, how much `ETH`(or token in terms of eth) is deposited. since `totalETHInPool` holds more amount than the actual, the ratio returned will be more than the actual ratio. Now this ratio will be returned back to `LRTDepositPool::getRsETHAmountToMint()` and it will perform the following calculation:

```Javascript
    function getRsETHAmountToMint(
        address asset,
        uint256 amount
    )
        public
        view
        override
        returns (uint256 rsethAmountToMint)
    {
        // setup oracle contract
        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);
        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);

        // calculate rseth amount to mint based on asset amount and asset exchange rate
        // @audit what if the tokens has different decimals?

@>        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();
    }

```

As you can see `lrtOracle::getRSETHPrice(...)` is in the denominator, that means bigger of the value returned from the function the lesser will be `rsethAmountToMint` which is the actual amount of `RSETH` tokens that user will be get. And that is the case in this situation. That means the amount of tokens will be minted to the user will be less than it should be. Hence user will be in loss.

Now this is not it, this problem will become even bigger if the amount transferred to `NodeDelegator` or `LRTDepositPool` is transferred to `EigenLayer` strategy. Because then we will not have any control of it in our hand. So that mean's this extra deposit made by the user should not be transferred to `EigenLayer` strategy. But that is not what's happening in the contracts. Here is a function that deposit asset in `EigenLayer`:

```Javascript
    function depositAssetIntoStrategy(address asset)
        external
        override
        whenNotPaused
        nonReentrant
        onlySupportedAsset(asset)
        onlyLRTManager
    {
        address strategy = lrtConfig.assetStrategy(asset);
        IERC20 token = IERC20(asset);
        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);

@>        uint256 balance = token.balanceOf(address(this));

        emit AssetDepositIntoStrategy(asset, strategy, balance);

@>        IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);
    }
```

As you can see, this also has the same issue that we talked earlier. This will also read the amount of token to be transferred to the strategy based on the same calculation `token.balanceOf(address(this))`. That mean's this will transfer all amount of tokens that is stored in the contracts and the following line of code will also fetch the wrong balance in `LRTDepositPool::getAssetDistributionData(...)` that we cannot even change as it only reads the amount of tokens deposited in the strategy from the strategy itself by using `NodeDelegator::getAssetBalance(...)` function:


```Javascript
    function getAssetDistributionData(address asset)
        public
        view
        override
        onlySupportedAsset(asset)
        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)
    {
        // Question: is here the right place to have this? Could it be in LRTConfig?
        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));

        uint256 ndcsCount = nodeDelegatorQueue.length;
        for (uint256 i; i < ndcsCount;) {
            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);
@>            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);
            unchecked {
                ++i;
            }
        }
    }
```

Now the amount of assets returned will always be more than the corresponding `RSETH` minted and the ratio will go high and the calculation will calculate less tokens to be minted for the user.
 

## Proof of Concept
Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.

## Tools Used

## Recommended Mitigation Steps